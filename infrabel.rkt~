#lang racket

(require "gui_simulator/interface.rkt") ; Simulator interface
;(require "hw_interface/interface.rkt") ; Hardware interface
(require "graphtrack.rkt")
(require (prefix-in q: "a-d/queue/linked.rkt"))

(provide set-speed! set-sw-position! get-train-dblock stopat set-route add-train travel-section travel-route)

; Total number of trains define the length of qvector
(define nr-of-trains 2)

; Setup and sart the simulator 
;(setup-loop-and-switches)
(setup-hardware)
(start) 

; Add train .
(define (add-train train previous-pos position)
  (add-loco (string->symbol (string-append "T-"(number->string train))) previous-pos position))

; The following tree functions are provided to ask for or set changes in the simulator.
(define (set-speed! train speed)
  (set-loco-speed! train speed))

(define (set-sw-position! switch position)
  (set-switch-position! switch position))

(define (get-train-dblock train)
  (get-loco-detection-block train))

; A thread to detect train location and set the train speed to zero when train is on dblock
(define (stopat dblock train)
  (thread (lambda ()
            (let loop ()
              (if (eq? (get-train-dblock train) dblock)
                  (set-speed! train 0)
                  (loop))))))

; vector to contain list with route sections at index train.
(define all-train-routes (make-vector (+ nr-of-trains 1)'()))

; cuts a route into subroutes, from dblock to dblock
(define (make-route-sections train route indexes)
  (define start caar)
  (define items cdar)
  (if (empty? indexes)
      (display (vector-ref all-train-routes train))
      (begin
        (vector-set! all-train-routes train (cons (slice route (start indexes)(items indexes))(vector-ref all-train-routes train)))
        (make-route-sections train route (cdr indexes))))) 

; calculates the indexes for the routes to be extracted from route in make-route-sections. 
(define (make-indexes route)
  (define return '())
  (define start car)
  (define next cadr)
  (let loop ((indexes  (indexes-where route (lambda (item)(not (equal? (substring  item 0 1)"S"))))))
    (if (> (length indexes) 1) 
        (begin
          (set! return(cons (cons (start indexes) (+ (- (next indexes) (start indexes))1)) return))
          (loop (cdr indexes)))
        return)))

; the actual list slicer to make sublists.
(define (slice list offset n)
  (take (drop list offset) n))

; this funtion is called from gui when send button is pushed
; it generates and prepares the route for a train.
(define (set-route to train)
  (let ((route (route-please (symbol->string (get-train-dblock (string->symbol train))) to))
        (train-nr (string->number(substring train 2 3))))
    (vector-set! all-train-routes train-nr '())
    (display route) ;o remove
    (make-route-sections (string->number(substring train 2 3)) route (make-indexes route))))

(define DBLOCKS 16)

;; vector for dblock reservations, if vector-ref #t dblock is free.
(define dblock-status (make-vector (+ DBLOCKS 1) #t))

;; extracts index from dblock name.
(define (get-dblock-nr position)
  (if (string<? position "2-1")
      (string->number (substring position 2 3))
      (+ (string->number (substring position 2 3)) 8)))
      
  
; A conditional to evoke functions based on the location, ex: set-sw-position! if location is a switch.
(define (get-switch-nr position)
  (if (string<? position "S100")
      (string->symbol(string-append "S-" (substring position 2 3)))
      (string->symbol(string-append "S-" (substring position 1 3)))))

(define (position-inspector position)
  (cond ((equal? (substring position 0 1)"S")
         (set-sw-position! (get-switch-nr position) (string->number (substring position 3 4))))
        (else (vector-set! dblock-status (get-dblock-nr position) #f))))

; function to handel a section of a train route, a section goes from dblock to next dblock.
(define (travel-section train section)
  (let ((start (first section))
        (destination (last section))
        (train (string->symbol(string-append "T-"(number->string train)))))
    (if (vector-ref dblock-status (get-dblock-nr destination))
        (begin
          (for-each (lambda (position)(position-inspector position))section)
          (if (direction? start destination)
              (set-speed! train 200)
              (set-speed! train -200)))
        'dest-not-free )))

(define (travel-route train)
  (define next-section car)
  (let loop ((route (vector-ref all-train-routes train)))
    (if (empty? route)
        'traveled
        (begin (travel-section train (next-section route))(loop (cdr route))))))

